#include "stdafx.h"

#include "TC_HemCalque.h"
#include "../helpful/EsrGuide.h"
#include "../helpful/PicketingInfo.h"
#include "../helpful/StrToTime.h"
#include "../Hem/RegulatoryLayer.h"
#include "../Hem/HappenLayer.h"
#include "../Hem/UncontrolledStations.h"

CPPUNIT_TEST_SUITE_REGISTRATION( TC_HemCalque );

static void setUncontrolled( attic::a_document& doc, int from, int to )
{
    doc.reset();
    doc.set_document_element("temporary");
    for( int i = from; i<=to; ++i )
    {
        EsrKit ek( i*100 );
        doc.document_element().append_child("UncontrolledSCB").append_attribute("ESR").set_value( ek.to_string() );
    }
}

static void setCalqulableOdd( attic::a_document& doc, int from, int to )
{
    doc.reset();
    doc.set_document_element("temporary");
    for( int i = from; i<=to; ++i )
    {
        EsrKit ek( i*100 );
        attic::a_node nn = doc.document_element().append_child("UncontrolledSCB");
        nn.brief_attribute("ESR", ek );
        nn.brief_attribute("SkipCalque", 0 == (i % 2) );
    }
}

void TC_HemCalque::solid()
{
    attic::a_document doc;
    setUncontrolled( doc, 1, 7 );
    uncontrolledStations->deserialize( doc.document_element() );
    load_only_6101();
    // генерируем начальное состояние калькирования
    CPPUNIT_ASSERT(  regul->calqueBuild( T(0,0,0), uncontrolledStations->getCalqulable(), m_AutoGeneratedNumbers ) == 1 );

    //
    HemHelpful::SpotEventPtr pr;
    HemHelpful::SpotEventPtr nx;
    {
        // калькируем начальное событие нормативной нити
        time_t t1 = T(1, 0, 0);
        CPPUNIT_ASSERT( !regul->calqueFound( t1   ) );
        CPPUNIT_ASSERT(  regul->calqueFound( t1+1 ) );
        std::tie( pr, nx ) = regul->calqueAnchorAndAppendix();
        CPPUNIT_ASSERT( !pr );
        CPPUNIT_ASSERT( match( nx, HCode::DEPARTURE, 100 ) );
        CPPUNIT_ASSERT( regul->calqueAccept(nx) );
    }
    // пробрасываем прочие события (если есть) до следующего события ЭТОЙ нити
    {
        const time_t t2 = T(2,0,0);
        CPPUNIT_ASSERT( skipTo( t2 ) );
        // калькируем следующее событие нормативной нити
        CPPUNIT_ASSERT( regul->calqueFound( t2+1 ) );
        std::tie( pr, nx ) = regul->calqueAnchorAndAppendix();
        CPPUNIT_ASSERT( match( pr, HCode::DEPARTURE, 100) );
        CPPUNIT_ASSERT( match( nx, HCode::ARRIVAL, 200 ) );
        CPPUNIT_ASSERT( regul->calqueAccept(nx) );
        CPPUNIT_ASSERT( !regul->calqueFound( t2+1 ) );
    }

    // пробрасываем прочие события (если есть) до последнего события ЭТОЙ нити
    const time_t t7 = T(7,0,0);
    CPPUNIT_ASSERT( skipTo( t7 ) );
    // калькируем последнее событие нормативной нити
    CPPUNIT_ASSERT( regul->calqueFound( t7+1 ) );
    std::tie( pr, nx ) = regul->calqueAnchorAndAppendix();
    CPPUNIT_ASSERT( match( pr, HCode::DEPARTURE, 600 ) );
    CPPUNIT_ASSERT( match( nx, HCode::ARRIVAL,   700 ) );
    CPPUNIT_ASSERT( regul->calqueAccept(nx) );
    CPPUNIT_ASSERT( !regul->calqueFound( t7+1 ) );
    CPPUNIT_ASSERT( !regul->calqueFound( t7+1000 ) );
}

void TC_HemCalque::prolog_epilog()
{
    // генерируем начальное состояние калькирования
    attic::a_document doc;
    setUncontrolled( doc, 2, 3 );
    uncontrolledStations->deserialize( doc.document_element() );
    load_only_6101();
    CPPUNIT_ASSERT(  regul->calqueBuild( T(0,0,0), uncontrolledStations->getCalqulable(), m_AutoGeneratedNumbers ) == 1 );
    //
    HemHelpful::SpotEventPtr pr;
    HemHelpful::SpotEventPtr nx;
    {
        // прибытие с прологом
        time_t t2 = T(2, 0, 0);
        CPPUNIT_ASSERT( !regul->calqueFound( t2   ) );
        CPPUNIT_ASSERT(  regul->calqueFound( t2+1 ) );
        std::tie( pr, nx ) = regul->calqueAnchorAndAppendix();
        CPPUNIT_ASSERT( !pr );
        CPPUNIT_ASSERT( match( nx, HCode::ARRIVAL, 200 ) );
        auto pro = regul->calqueProlog( *esrGuide );
        CPPUNIT_ASSERT( pro );
        CPPUNIT_ASSERT( match( pro, HCode::SPAN_MOVE, EsrKit(100,200) ) );
        CPPUNIT_ASSERT( timeLess( pro, nx ) );
        CPPUNIT_ASSERT( regul->calqueAccept(nx) );
    }
    // следующим будет отправление
    {
        const time_t t202 = T(2,2,0);
        // калькируем следующее событие нормативной нити
        CPPUNIT_ASSERT( regul->calqueFound( t202+1 ) );
        std::tie( pr, nx ) = regul->calqueAnchorAndAppendix();
        CPPUNIT_ASSERT( match( pr, HCode::ARRIVAL,   200 ) );
        CPPUNIT_ASSERT( match( nx, HCode::DEPARTURE, 200 ) );
        CPPUNIT_ASSERT( regul->calqueAccept(nx) );
        CPPUNIT_ASSERT( !regul->calqueFound( t202+1 ) );
    }
    // затем проследование и эпилог т.к. неконтролируемая зона закончилась
    {
        const time_t t3 = T(3,0,0);
        // калькируем следующее событие нормативной нити
        CPPUNIT_ASSERT( regul->calqueFound( t3+1 ) );
        std::tie( pr, nx ) = regul->calqueAnchorAndAppendix();
        CPPUNIT_ASSERT( match( pr, HCode::DEPARTURE,  200 ) );
        CPPUNIT_ASSERT( match( nx, HCode::TRANSITION, 300 ) );
        auto epi = regul->calqueEpilog( *esrGuide );
        CPPUNIT_ASSERT( epi );
        CPPUNIT_ASSERT( match( epi, HCode::SPAN_MOVE, EsrKit(300,400) ) );
        CPPUNIT_ASSERT( timeLess( nx, epi ) );
        CPPUNIT_ASSERT( regul->calqueAccept(nx) );
        CPPUNIT_ASSERT( !regul->calqueFound( t3+1 ) );
        CPPUNIT_ASSERT( !regul->calqueFound( t3+1000 ) );
    }
}

void TC_HemCalque::some_calqulable()
{
    attic::a_document doc;
    setCalqulableOdd( doc, 1, 5 );
    uncontrolledStations->deserialize( doc.document_element() );

    CPPUNIT_ASSERT( uncontrolledStations->contains( EsrKit(100) ) );
    CPPUNIT_ASSERT( uncontrolledStations->contains( EsrKit(200) ) );
    CPPUNIT_ASSERT( uncontrolledStations->contains( EsrKit(300) ) );
    CPPUNIT_ASSERT( uncontrolledStations->contains( EsrKit(400) ) );
    CPPUNIT_ASSERT( uncontrolledStations->contains( EsrKit(500) ) );

    CalqulableStations cs = uncontrolledStations->getCalqulable();
    CPPUNIT_ASSERT( 3 == cs.get_all().size() );
    CPPUNIT_ASSERT( cs.contains( EsrKit(100) ) );
    CPPUNIT_ASSERT( cs.contains( EsrKit(300) ) );
    CPPUNIT_ASSERT( cs.contains( EsrKit(500) ) );
}

void TC_HemCalque::load_save()
{
    attic::a_document doc;
    setCalqulableOdd( doc, 1, 7 );
    uncontrolledStations->deserialize( doc.document_element() );

    attic::a_document doc2( doc.document_element().name() );
    uncontrolledStations->serialize( doc2.document_element() );

    CPPUNIT_ASSERT( attic::identical( doc, doc2 ) );
}

bool TC_HemCalque::skipTo( time_t moment )
{
    bool result = true;
    while( result && regul->calqueFound( moment ) )
    {
        HemHelpful::SpotEventPtr p;
        HemHelpful::SpotEventPtr n;
        std::tie( p, n ) = regul->calqueAnchorAndAppendix();
        if ( n )
            result = regul->calqueAccept(n);
        else
            result = false;
    }
    return result;
}

time_t TC_HemCalque::T( unsigned h, unsigned m, unsigned s )
{
    auto res = time_from_iso( "20180412T000000Z");
    res += h * 3600 + m * 60 + s;
    return res;
}

bool TC_HemCalque::match(HemHelpful::SpotEventPtr pr, HCode code, int esr)
{
    return match( pr, code, EsrKit(esr) );
}

bool TC_HemCalque::match(HemHelpful::SpotEventPtr pr, HCode code, EsrKit esr)
{
    return pr && pr->GetCode() == code && pr->GetBadge().num() == esr;
}
bool TC_HemCalque::timeLess(std::shared_ptr<const SpotEvent> one, std::shared_ptr<const SpotEvent> two )
{
    return one && two && one->GetTime() < two->GetTime();
}

void TC_HemCalque::load_only_6101()
{
    const std::wstring normData =
        L"<export>\n"
        L" <ScheduledLayer timePeriod='[2018-Apr-11 15:00:00/2018-Apr-13 14:59:59.999997]'>"
        L"  <ScheduledPath>"
        L"   <SpotEvent create_time='20180412T010000Z' name='Info_changing' Bdg='№6101[00100]' index='' num='6101' suburbreg='Y' />"
        L"   <SpotEvent create_time='20180412T010000Z' name='Departure'  Bdg='№6101[00100]' />"
        L"   <SpotEvent create_time='20180412T020000Z' name='Arrival'    Bdg='№6101[00200]' />"
        L"   <SpotEvent create_time='20180412T020200Z' name='Departure'  Bdg='№6101[00200]' />"
        L"   <SpotEvent create_time='20180412T030000Z' name='Transition' Bdg='№6101[00300]' />"
        L"   <SpotEvent create_time='20180412T040000Z' name='Arrival'    Bdg='№6101[00400]' />"
        L"   <SpotEvent create_time='20180412T040400Z' name='Departure'  Bdg='№6101[00400]' />"
        L"   <SpotEvent create_time='20180412T050000Z' name='Transition' Bdg='№6101[00500]' />"
        L"   <SpotEvent create_time='20180412T060000Z' name='Arrival'    Bdg='№6101[00600]' />"
        L"   <SpotEvent create_time='20180412T060600Z' name='Departure'  Bdg='№6101[00600]' />"
        L"   <SpotEvent create_time='20180412T070000Z' name='Arrival'    Bdg='№6101[00700]' />"
        L"  </ScheduledPath>"
        //         L"  <ScheduledPath>"
        //         L"   <SpotEvent create_time='20180412T031200Z' name='Info_changing' Bdg='№6102[00700]' index='' num='6102' suburbreg='Y' />"
        //         L"   <SpotEvent create_time='20180412T031230Z' name='Departure'  Bdg='№6102[00700]' />"
        //         L"   <SpotEvent create_time='20180412T032330Z' name='Arrival'    Bdg='№6102[00600]' />"
        //         L"   <SpotEvent create_time='20180412T032430Z' name='Departure'  Bdg='№6102[00600]' />"
        //         L"   <SpotEvent create_time='20180412T032630Z' name='Transition' Bdg='№6102[00500]' />"
        //         L"   <SpotEvent create_time='20180412T033130Z' name='Arrival'    Bdg='№6102[00400]' />"
        //         L"   <SpotEvent create_time='20180412T033200Z' name='Departure'  Bdg='№6102[00400]' />"
        //         L"   <SpotEvent create_time='20180412T033700Z' name='Transition' Bdg='№6102[00300]' />"
        //         L"   <SpotEvent create_time='20180412T034300Z' name='Arrival'    Bdg='№6102[00200]' />"
        //         L"  </ScheduledPath>"
        L" </ScheduledLayer>"
        L"</export>";

    {
        attic::a_document doc;
        CPPUNIT_ASSERT(doc.load_wide(normData));
        regul->deserialize(doc.document_element());
        regul->takeChanges(attic::a_node());
    }
}

void TC_HemCalque::setUp()
{
    regul.reset( new Regulatory::Layer );
    uncontrolledStations.reset( new UncontrolledStations );
    esrGuide.reset( new EsrGuide );

    auto egSet = [this]( int esr, const std::string& km )
    {
        PicketingInfo pi;
        pi.SetCoord( rwRuledCoord( L"testDir", rwCoord(km) ) );
        esrGuide->setNameAndAxis( EsrKit(esr), L"Term"+std::to_wstring(esr), pi );
    };

    egSet( 100, "100" );
    egSet( 200, "200" );
    egSet( 300, "300" );
    egSet( 400, "400" );
    egSet( 500, "500" );
    egSet( 600, "600" );
    egSet( 700, "700" );

    //Диапазоны номеров, калькируемых по нормативке по умолчанию.
    m_AutoGeneratedNumbers.clear();
    m_AutoGeneratedNumbers.emplace_back(701,899);
    m_AutoGeneratedNumbers.emplace_back(5001,7998);
}

void TC_HemCalque::tearDown()
{
    regul.reset();
    uncontrolledStations.reset();
}
